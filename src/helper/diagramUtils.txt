import { ConnectorModel, DiagramComponent, NodeConstraints, NodeModel, Point, PointPortModel, PortConstraints, PortModel, PortVisibility, SnapConstraints } from "@syncfusion/ej2-react-diagrams";
import { DiagramSettings, NodeCategories, NodeConfig, NodeDimensions, NodePortDirection, NodeTemplate, PortConfiguration, PortSide } from "../types";
import { NODE_DIMENSIONS, PORT_POSITIONS } from "../constants";
import html2canvas from "html2canvas";

// Get sticky note template
export const getStickyNoteTemplate = (diagram: DiagramComponent, nodeId: string): string => {
  // Get stored markdown content from node data
  const node = diagram?.nodes?.find(n => n.id === nodeId);
  const storedMarkdown = (node?.addInfo as any)?.markdown || 'Double-click to edit\n\nYou can use **bold**, *italic*, `code`, and\n# Headers\n- Lists';
  const markdownHtml = convertMarkdownToHtml(storedMarkdown);

  return `
    <div class="sticky-note-container" data-node-id="${nodeId}">
        <div class="sticky-note-content">
        <div class="markdown-preview" id="preview-${nodeId}" style="display: block;">
            ${markdownHtml}
        </div>
        <textarea class="markdown-editor" 
            id="editor-${nodeId}" 
            style="display: none;"
            placeholder="Type your markdown here..."
        />
        </div>
    </div>
    `;
};

// Simple markdown to HTML converter for sticky node
export const convertMarkdownToHtml = (markdown: string): string => {
  if (!markdown) return '';

  return markdown
    // Headers
    .replace(/^### (.*$)/gim, '<h3>$1</h3>')
    .replace(/^## (.*$)/gim, '<h2>$1</h2>')
    .replace(/^# (.*$)/gim, '<h1>$1</h1>')
    // Bold and italic
    .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')
    .replace(/\*(.*?)\*/g, '<em>$1</em>')
    // Code
    .replace(/`(.*?)`/g, '<code>$1</code>')
    // Lists
    .replace(/^- (.*$)/gim, '<li>$1</li>')
    .replace(/(<li>.*<\/li>)/g, '<ul>$1</ul>')
    // Line Break
    .replace(/\n/g, '<br>');
};

// Returns the first selected node in the diagram
export function getFirstSelectedNode(diagram: DiagramComponent | null | undefined): NodeModel | undefined {
  if (!diagram || !diagram.selectedItems || !Array.isArray(diagram.selectedItems.nodes)) return undefined;
  if (diagram.selectedItems.nodes.length === 0) return undefined;
  return diagram.selectedItems.nodes[0];
}

// Generates an optimized thumbnail from an HTML element and returns it as a base64 encoded JPEG.
export const generateOptimizedThumbnail = async (elementId: string): Promise<string | undefined> => {
  const element = document.getElementById(elementId);
  if (!element) {
    console.warn(`Element with ID "${elementId}" not found for thumbnail generation.`);
    return undefined;
  }

  try {
    // Render with a specific scale, then resize precisely for optimization
    const canvas = await html2canvas(element as HTMLElement, {
      backgroundColor: '#bbc7d6',
      scale: 1,
      useCORS: true,
      logging: false,
      allowTaint: true,
    });

    // Define target dimensions for the thumbnail
    const maxW = 420;
    const maxH = 240;

    // Calculate the best-fit ratio to maintain aspect ratio without stretching
    const ratio = Math.min(maxW / canvas.width, maxH / canvas.height, 1);
    const outW = Math.max(1, Math.round(canvas.width * ratio));
    const outH = Math.max(1, Math.round(canvas.height * ratio));

    const outputCanvas = document.createElement('canvas');
    outputCanvas.width = outW;
    outputCanvas.height = outH;
    const ctx = outputCanvas.getContext('2d');

    if (ctx) {
      // Enable image smoothing for better quality on downscaling
      ctx.imageSmoothingEnabled = true;
      ctx.imageSmoothingQuality = 'high';
      ctx.drawImage(canvas, 0, 0, outW, outH);

      // Return JPEG with moderate quality to keep file size small
      return outputCanvas.toDataURL('image/jpeg', 0.65);
    }

    return undefined;
  } catch (error) {
    console.warn('Thumbnail generation failed, continuing without thumbnail.', error);
    return undefined;
  }
};

export const getDefaultDiagramSettings = (): DiagramSettings => {
  const diagramSettings: DiagramSettings = {
    gridStyle: 'dotted',
    connectorType: 'Orthogonal',
    connectorCornerRadius: 10,
    snapping: { isEnabled: true, enableSnapToGrid: true, enableSnapToObjects: false },
    showOverview: true,
    showOverviewAlways: false,
  };
  return diagramSettings;
}

export const getGridType = (diagramSettings: DiagramSettings) => {
  if (!diagramSettings?.gridStyle || diagramSettings.gridStyle === 'none') return 'Lines';
  return diagramSettings.gridStyle === 'lines' ? 'Lines' : 'Dots';
};

export const getGridColor = (diagramSettings: DiagramSettings) => {
  if (diagramSettings?.gridStyle === 'none') return 'transparent';
  if (diagramSettings?.gridStyle === 'lines') return 'var(--grid-line-color)';
  return 'var(--grid-dotted-color)';
};

export const getSnapConstraints = (diagramSettings: DiagramSettings) => {
  if (!diagramSettings?.snapping.isEnabled) return SnapConstraints.ShowLines;

  let constraints = SnapConstraints.ShowLines;
  if (diagramSettings?.snapping.enableSnapToGrid) {
    constraints |= SnapConstraints.SnapToLines        // snaps to both H & V grid lines (grid)
  }
  if (diagramSettings?.snapping.enableSnapToObjects) {
    constraints |= SnapConstraints.SnapToObject;      // snaps to nearby objects
  }

  return constraints;

};

export const getConnectorType = (diagramSettings: DiagramSettings) => {
  return diagramSettings?.connectorType;
};

export const getConnectorCornerRadius = (diagramSettings: DiagramSettings) => {
  if (diagramSettings?.connectorType === 'Orthogonal') return diagramSettings.connectorCornerRadius;
  return 0;
};

export const bringConnectorsToFront = (diagram: DiagramComponent) => {
  // Select all connectors
  diagram.select(diagram.connectors);

  // Move selected connectors forward
  diagram.bringToFront();

  // Clear selection to avoid UI side effects
  diagram.clearSelection();
}

// Check if a node is a trigger type
export const isTriggerNode = (nodeConfig: NodeConfig): boolean =>
  nodeConfig?.category === 'trigger';

// Check if a node is an action type
export const isActionNode = (nodeConfig: NodeConfig): boolean =>
  nodeConfig?.category === 'action';

// Check if a node is a condition type
export const isConditionNode = (nodeConfig: NodeConfig): boolean =>
  nodeConfig?.category === 'condition';

// Check if a node is an AI agent type
export const isAiAgentNode = (nodeConfig: NodeConfig): boolean =>
  nodeConfig?.category === 'ai-agent';

// Check if a node is a sticky note
export const isStickyNote = (nodeConfig: NodeConfig): boolean =>
  nodeConfig?.category === 'sticky';

// Check if node is an if/switch condition type
export const isIfOrSwitchCondition = (nodeConfig: NodeConfig): boolean =>
  isConditionNode(nodeConfig) &&
  (nodeConfig.nodeType === 'If Condition' || nodeConfig.nodeType === 'Switch Case');

// Get the appropriate port rendering configuration for a node


export const getNodePortConfiguration = (nodeConfig: NodeConfig): PortConfiguration => {
  if (isTriggerNode(nodeConfig)) {
    return { rightPort: true };
  }

  if (isIfOrSwitchCondition(nodeConfig)) {
    return { leftPort: true, rightTopPort: true, rightBottomPort: true };
  }

  if (isAiAgentNode(nodeConfig)) {
    return {
      leftPort: true,
      rightPort: true,
      bottomLeftPort: true,
      bottomMiddlePort: true,
      bottomRightPort: true
    };
  }

  // Default for action nodes
  return { leftPort: true, rightPort: true };
};


// Convert direction to side
export const getPortSide = (direction: NodePortDirection): PortSide =>
  direction.startsWith('right') ? 'Right' : 'Bottom';

// Convert direction to offset
export const getPortOffset = (direction: NodePortDirection): number => {
  const offsetMap: Record<NodePortDirection, number> = {
    right: 0.5,
    'right-top': 0.3,
    'right-bottom': 0.7,
    'bottom-left': 0.25,
    'bottom-middle': 0.5,
    'bottom-right': 0.75,
  };
  return offsetMap[direction] ?? 0.5;
};

// Store the port ID and direction info for dynamic userhandle rendering
export function prepareUserHandlePortData(node: NodeModel): void {
  // Infers the direction of a port based on its offset
  const inferDirection = (port: PortModel): NodePortDirection => {
    const pointPort = port as PointPortModel;
    if (pointPort?.offset) {
      const { x, y } = pointPort.offset as Point;
      if (x === 1 && y === 0.5) return 'right';
      if (x === 0.25 && y === 1) return 'bottom-left';
      if (x === 0.5 && y === 1) return 'bottom-middle';
      if (x === 0.75 && y === 1) return 'bottom-right';
      if (x === 1 && y === 0.3) return 'right-top';
      if (x === 1 && y === 0.7) return 'right-bottom';
    }
    return 'right'; // Default fallback direction
  };

  if (!node.ports) return;

  // Filter ports that support both OutConnect and Draw constraints
  const connectablePorts = node.ports
    .filter(
      (p) =>
        p.constraints !== undefined &&
        (p.constraints & PortConstraints.OutConnect) !== 0 &&
        (p.constraints & PortConstraints.Draw) !== 0
    )
    // Map each port to its ID and inferred direction
    .map((port) => ({
      portId: port.id,
      direction: inferDirection(port),
    }));

  if (connectablePorts.length > 0) {
    if (!node.addInfo) node.addInfo = {};
    // Store the port ID and direction info under userHandlesAtPorts
    (node.addInfo as any).userHandlesAtPorts = connectablePorts;
  }
}

// Retrieves a specific port from a given node by its ID.
export function getNodePortById(node: NodeModel | null | undefined, portId: string): PortModel | undefined {
  // Ensure the node, its ports array, and the portId are valid before searching
  if (!node || !node.ports || !Array.isArray(node.ports) || !portId) {
    return undefined;
  }

  // Find the port that matches the provided ID
  return node.ports.find((p: PortModel) => p.id === portId);
}

// Sets the constraints for nodes
export function updateNodeConstraints(node: NodeModel) {
  const nodeConfig = getNodeConfig(node);

  // Base constraints remain the same
  let baseConstraints = NodeConstraints.Default &
    ~NodeConstraints.Rotate &
    ~NodeConstraints.InConnect &
    ~NodeConstraints.OutConnect;

  // For sticky note node, don't hide the thumbs (this enables resizing for sticky notes)
  node.constraints = nodeConfig && isStickyNote(nodeConfig)
    ? baseConstraints
    : (baseConstraints & ~NodeConstraints.Resize) | NodeConstraints.HideThumbs | NodeConstraints.ReadOnly;
}

// Calculates the optimal position for a new node based on the source node and port.
export const calculateNewNodePosition = (sourceNode: NodeModel, portId: string): { offsetX: number, offsetY: number } => {
  const {
    offsetX: baseX = 80,
    offsetY: baseY = 80,
    width: nodeWidth = 150,
    height: nodeHeight = 100
  } = sourceNode;

  const horizontalSpacing = nodeWidth * 2;
  const verticalSpacing = nodeHeight * 2;
  const padding = 50;

  // Start with a sensible default position (to the right of the source node)
  let offsetX = baseX + horizontalSpacing;
  let offsetY = baseY;

  // Handle specific port IDs for fine-tuned positioning
  switch (portId) {
    // --- AI Agent Ports ---
    case 'bottom-left-port':
      offsetX = baseX - (nodeWidth + padding / 2);
      offsetY = baseY + verticalSpacing;
      break;
    case 'bottom-middle-port':
      offsetX = baseX; // Directly below
      offsetY = baseY + verticalSpacing;
      break;
    case 'bottom-right-port':
      offsetX = baseX + (nodeWidth + padding / 2);
      offsetY = baseY + verticalSpacing;
      break;

    // --- IF Condition Ports ---
    case 'right-top-port':
      offsetX = baseX + horizontalSpacing;
      offsetY = baseY - (nodeHeight / 2 + padding); // To the right and above
      break;
    case 'right-bottom-port':
      offsetX = baseX + horizontalSpacing;
      offsetY = baseY + (nodeHeight / 2 + padding); // To the right and below
      break;

    default:
      break;
  }

  return { offsetX, offsetY };
};

// Safely retrieves NodeConfig from a node's addInfo
export const getNodeConfig = (node: NodeModel | null | undefined): NodeConfig | undefined => {
  if (!node?.addInfo) return undefined;
  return (node.addInfo as any)?.nodeConfig;
};

// Get node display name safely
export const getNodeDisplayName = (node: NodeModel | null | undefined): string => {
  const config = getNodeConfig(node);
  return config?.displayName || 'Unnamed Node';
};

export const getNodeDimensions = (node: NodeModel): NodeDimensions => {
  const config = getNodeConfig(node);

  if (!config) return NODE_DIMENSIONS.DEFAULT;

  if (isAiAgentNode(config)) return NODE_DIMENSIONS.AI_AGENT;
  if (isStickyNote(config)) return NODE_DIMENSIONS.STICKY_NOTE;

  return NODE_DIMENSIONS.DEFAULT;
};

// Initialize node dimensions while preserving existing valid dimensions
export const initializeNodeDimensions = (node: NodeModel) => {
  const dimensions = getNodeDimensions(node);
  const nodeConfig = getNodeConfig(node);

  if (!node.width || node.width === 0) node.width = dimensions.WIDTH;
  if (!node.height || node.height === 0) node.height = dimensions.HEIGHT;

  if (nodeConfig && isStickyNote(nodeConfig) && dimensions.MIN_WIDTH && dimensions.MIN_HEIGHT) {
    node.minWidth = dimensions.MIN_WIDTH;
    node.minHeight = dimensions.MIN_HEIGHT;
  }
};

// Validate node position
export const hasValidPosition = (node: NodeModel): boolean => {
  return Boolean(
    node.offsetX &&
    node.offsetX !== 0 &&
    node.offsetY &&
    node.offsetY !== 0
  );
};

// Diagram state management utilities
export const hasDiagramNodes = (diagram: DiagramComponent | null): boolean => {
  return Boolean(diagram?.nodes?.length);
};

export const getNodesOfType = (diagram: DiagramComponent | null, type: string): NodeModel[] => {
  if (!diagram?.nodes) return [];
  return diagram.nodes.filter(node => getNodeConfig(node)?.nodeType === type);
};

// Check if a node is valid and has proper configuration
export const isValidNode = (node: NodeModel | null | undefined): boolean => {
  if (!node) return false;
  const config = getNodeConfig(node);
  return Boolean(config && config.id && config.category);
};

export const isNodeSelected = (diagram: DiagramComponent | null, nodeId: string): boolean => {
  return diagram?.selectedItems?.nodes?.some(node => node.id === nodeId) || false;
};

// Creates a new node model from a node template
export const createNodeFromTemplate = (
  nodeTemplate: NodeTemplate,
  position?: { x: number; y: number }
): NodeModel => {
  const nodeId = `${nodeTemplate.id}-${Date.now()}`;
  const nodeConfig: NodeConfig = {
    id: nodeId,
    nodeType: nodeTemplate.nodeType,
    category: nodeTemplate.category,
    displayName: nodeTemplate.name,
    icon: nodeTemplate.iconId,
    settings: { general: {}, authentication: {}, advanced: {} },
  };

  const node: NodeModel = {
    id: nodeId,
    offsetX: position?.x,
    offsetY: position?.y,
    addInfo: { nodeConfig },
    ports: getPortsForNode(nodeTemplate.category)
  };

  initializeNodeDimensions(node);
  return node;
};

export const createPort = (
  id: string,
  offset: { x: number; y: number },
  shape: "Circle" | "Square" = "Circle",
  size: number = 20,
  constraints: PortConstraints,
  tooltip?: string
): PointPortModel => ({
  id,
  offset,
  shape,
  height: size,
  width: size,
  style: { fill: "transparent", strokeColor: "transparent" },
  visibility: PortVisibility.Visible,
  constraints,
  ...(tooltip ? { tooltip: { content: tooltip } } : {}),
});

export const getPortsForNode = (type: NodeCategories): PortModel[] => {
  switch (type) {
    case "ai-agent":
      return [
        createPort("left-port", PORT_POSITIONS.AI_AGENT_LEFT, "Circle", 20, PortConstraints.InConnect),
        createPort("right-port", PORT_POSITIONS.RIGHT, "Circle", 20, PortConstraints.OutConnect | PortConstraints.Draw),
        createPort("bottom-left-port", PORT_POSITIONS.BOTTOM_LEFT, "Square", 14, PortConstraints.OutConnect | PortConstraints.Draw, "Chat Model"),
        createPort("bottom-middle-port", PORT_POSITIONS.BOTTOM_MIDDLE, "Square", 14, PortConstraints.OutConnect | PortConstraints.Draw, "Memory"),
        createPort("bottom-right-port", PORT_POSITIONS.BOTTOM_RIGHT, "Square", 14, PortConstraints.OutConnect | PortConstraints.Draw, "Tools"),
      ];

    case "condition":
      return [
        createPort("left-port", PORT_POSITIONS.LEFT, "Circle", 20, PortConstraints.InConnect),
        createPort("right-top-port", PORT_POSITIONS.RIGHT_TOP, "Circle", 20, PortConstraints.OutConnect | PortConstraints.Draw),
        createPort("right-bottom-port", PORT_POSITIONS.RIGHT_BOTTOM, "Circle", 20, PortConstraints.OutConnect | PortConstraints.Draw),
      ];

    case "trigger":
      return [
        createPort("right-port", PORT_POSITIONS.RIGHT, "Circle", 20, PortConstraints.OutConnect | PortConstraints.Draw),
      ];

    default: // action node
      return [
        createPort("left-port", PORT_POSITIONS.LEFT, "Circle", 20, PortConstraints.InConnect),
        createPort("right-port", PORT_POSITIONS.RIGHT, "Circle", 20, PortConstraints.OutConnect | PortConstraints.Draw),
      ];
  }

};


// Creates a connector between two nodes
export const createConnector = (
  sourceId: string,
  targetId: string,
  sourcePortId: string,
  targetPortId: string = 'left-port'
): ConnectorModel => ({
  id: `connector-${Date.now()}`,
  sourceID: sourceId,
  targetID: targetId,
  sourcePortID: sourcePortId,
  targetPortID: targetPortId
});